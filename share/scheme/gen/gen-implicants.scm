;;;
;;;	The Balsa Asynchronous Hardware Synthesis System
;;;	Copyright (C) 1995-2003 Department of Computer Science
;;;	The University of Manchester, Oxford Road, Manchester, UK, M13 9PL
;;;	
;;;	This program is free software; you can redistribute it and/or modify
;;;	it under the terms of the GNU General Public License as published by
;;;	the Free Software Foundation; either version 2 of the License, or
;;;	(at your option) any later version.
;;;	
;;;	This program is distributed in the hope that it will be useful,
;;;	but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;	GNU General Public License for more details.
;;;	
;;;	You should have received a copy of the GNU General Public License
;;;	along with this program; if not, write to the Free Software
;;;	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
;;;
;;;	`gen-implicants.scm'
;;;	Procedures for handling implicant lists esp. for Case, CaseFetch handling
;;;
;;;	$Id: gen-implicants.scm,v 1.8 2003/02/08 19:39:43 bardslea Exp $
;;;

(balsa-scheme-import 'misc 'implicants)
(balsa-scheme-import 'brz)

;;; NB. These procedures require the procedures: lognot, logand, logior and bit-extract
;;;   to be defined

;;; zero-bottom-bits: returns `val' with the bottom `n' bits replaced by zeroes
(define zero-bottom-bits (lambda (val n)
	(* (expt 2 n) (shift-right val n))
))

;;; gen-make-implicant-list-for-range: Returns a list of implicants in the form (base-value dont-care-count)
;;;	  to represent the range [start,end]. eg. list element (12 2) represents the implicant 11--
(define gen-make-implicant-list-for-range (lambda (start end)
	(letrec
		; find the implicants from base to end and add to the implicants list (tail recurs.)
		((find-implicants (lambda (base implicants)
			(letrec
				; count the number of don't cares which we can safely insert here
				((count-dont-cares (lambda (mask bitNo)
					(if (or (> base (zero-bottom-bits base (+ 1 bitNo))) (< end (logior mask base))) ; range too big
						bitNo
						(count-dont-cares (logior 1 (ash mask 1)) (+ 1 bitNo)) ; extend mask, continue
					)
				)))
				(if (> base end) ; past the end of range?
					implicants
					(let
						((bitNo (count-dont-cares 1 0)))
						(find-implicants (+ base (ash 1 bitNo)) (cons (list base bitNo) implicants))
					)
				)
			)
		)))
		(find-implicants start '())
	)
))

;;; gen-make-dont-care-binary-string: Produces a binary representation in the same way as binary-string
;;;   but places dont-care-count hyphen in the least significant bits eg. (8 15 2) => "000011--"
(define gen-make-dont-care-binary-string (lambda (width value dont-care-count)
	(let*
		((n-dashes (lambda (n) (make-string n #\-))))
		(string-append
			(substring (radix-string 2 value width) 0 (- width dont-care-count))
			(n-dashes dont-care-count)
		)
	)
))

;;; gen-make-implicant-strings-for-range: Like make-implicant-list-for-range but produces a list of
;;;   string representations
(define gen-make-implicant-strings-for-range (lambda (width start end)
	(map
		(lambda (imp) (apply gen-make-dont-care-binary-string (cons width imp)))
		(gen-make-implicant-list-for-range start end)
	)
))

;;; gen-make-string-implicants: make a list of list of implicants (in the string representation
;;;		with #\- #\0 and #\1) for the given parsed-case-spec (which is a span list list).
(define gen-make-string-implicants (lambda (parsed-case-spec width)
	(map (lambda (spans)
		(map (lambda (span)
			(gen-make-implicant-strings-for-range width (span:lower span) (span:upper span))
		) spans)
	) parsed-case-spec)
))

;;; gen-make-case-spec-implicants: make a list of lists of implicants which 
;;;		encode the given case spec.  One list per output	
;;;		`parsed-case-spec' is the result of brz-parse-case-spec
(define gen-make-case-spec-implicants (lambda (parsed-case-spec)
	(map (lambda (terms)
		(reverse! (foldl (lambda (imps term)
			(case (car term)
				((value) (cons (cons (cadr term) 0) imps))
				((range) (append!
					(make-implicant-list-for-range (cadr term) (caddr term))
					imps
				))
				((implicant) (cons (cons (cadr term) (caddr term)) imps))
			)
		) '() terms))
	) parsed-case-spec)
))

;;; gen-and-term-gates generate a list of "and"-gates from list of 
;;; or-terms i.e (((2.0) ((1.0)) ((0.0))) generated by gen-make-sop-for-espresso 
;;; where the first value represents the bit-index and the second the group index
(define gen-and-term-gates (lambda (and-terms)
	(map (lambda (term index)
		(cons 'and-gate (cons (internal-wire index)
			(foldl (lambda (res terminal)
				(if (null? terminal)
					res
					(append res
						(map (lambda (terminus)
							(list-ref (list-ref input-slices (cdr terminus)) (car terminus))
						) terminal)
					)
				)
			) '() term)
		))
	 ) and-terms (.. 0 (- term-count 1)))
))

;;; gen-or-term-gates generate a list of or-gates, or gnd connections from list of 
;;; or-terms i.e (0 1 2) generated by gen-make-sop-for-espresso
(define gen-or-term-gates (lambda (or-terms) 
	(letrec
		((make-or (lambda (portion-index output-index tail res)
			(if (null? tail)
				res
				(make-or
					(modulo (+ portion-index 1) num-output-slices)
					(+ output-index 1)
					(cdr tail)
					(cons
						(cond
							((null? (car tail)) ; 0
								(list 'connect
									(list 'node tech-gnd-net-name 0 0 1)
									(list-ref (list-ref output-slices  portion-index) output-index)
								)
							)
							(else (cons 'or 
								(cons (list-ref (list-ref output-slices  portion-index) output-index)
								(map internal-wire (car tail)))))
						)
						res
					)
				)
			)
		)))
		(make-or 0 0 or-terms '())
	)
))
