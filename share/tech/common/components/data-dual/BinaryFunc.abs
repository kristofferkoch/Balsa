(defines
	; operation types
	(logical-op (case (param "op") (("And" "Or" "Xor") #t) (else #f)))
	(arith-op (case (param "op") (("Add" "Subtract") #t) (else #f)))
	(subtractive-op (= (param "op") "Subtract"))
	(equality-op (case (param "op") (("Equals" "NotEquals") #t) (else #f)))
	(lt-inequality-op
		(case (param "op")
			  (("LessThan" "GreaterOrEquals") #t)
			  (else #f)
		)
	)
	(gt-inequality-op
		(case (param "op")
			  (("GreaterThan" "LessOrEquals") #t)
			  (else #f)
		)
	)
	(inequality-op
		(case (param "op")
			  (("LessThan" "GreaterThan" "LessOrEquals" "GreaterOrEquals") #t)
			  (else #f)
		)
	)
	; widths and signedness of wide and narrow inputs
	(output-width (param "outputWidth"))
	(max-input-width (max (param "inputAWidth") (param "inputBWidth")))
	(max-width
		(if (or equality-op inequality-op) max-input-width
			(min output-width max-input-width)
		)
	)
	(a-width (min max-width (param "inputAWidth")))
	(b-width (min max-width (param "inputBWidth")))
	(a-is-widest (>= a-width b-width))
	(w-width (if a-is-widest a-width b-width))
	(w-signed (if a-is-widest (= "true" (param "inputAIsSigned")) (= "true" (param "inputBIsSigned"))))
	(n-width (if a-is-widest b-width a-width))
	(n-signed (if a-is-widest (= "true" (param "inputBIsSigned")) (= "true" (param "inputAIsSigned"))))
	(signed-op (or n-signed w-signed))
	; doing signed x unsigned need to extend range of the unsigned input
	; giving an extra bit to the output if the unsigned number is
	; larger or equal in length to the signed number
	(signed-unsigned-op
		(and (not logical-op)
			(or (not arith-op) (> output-width w-width)) 
			(/= w-signed n-signed)
			(or (not w-signed) ; unsigned is largest or equal
				(and w-signed (= w-width n-width)) ; unsigned is equal
			)
		)
	)
	(full-add-width (+ (if signed-unsigned-op 1 0) w-width))
	(n-extend-width (- full-add-width n-width))
	(out-extend-width (- output-width full-add-width))
	; Define cells according to style options:
	(dual-rail-and2
		(case logic-type
			(("ncl") "dual-rail-and2-ncl")
			(("balanced") "dual-rail-and2-bal")
			(else "dual-rail-and2")
		)
	)
	(dual-rail-or2
		(case logic-type
			(("ncl") "dual-rail-or2-ncl")
			(("balanced") "dual-rail-or2-bal")
			(else "dual-rail-or2")
		)
	)
	(dual-rail-xor2
		(case logic-type
			(("ncl") "dual-rail-xor2-ncl")
			(else "dual-rail-xor2")
		)
	)
	(dual-rail-ao21
		(case logic-type
			(("ncl") "dual-rail-ao21-ncl")
			(("balanced") "dual-rail-ao21-bal")
			(else "dual-rail-ao21")
		)
	)
	(dual-rail-ineq-comp
		(case logic-type
			(("ncl") "dual-rail-ineq-comp-ncl")
			(("balanced") "dual-rail-ineq-comp-bal")
			(else "dual-rail-ineq-comp")
		)
	)
	(dual-rail-half-adder
		(case logic-type
			(("ncl") "dual-rail-half-adder-ncl")
			(("balanced") "dual-rail-half-adder-bal")
			(else "dual-rail-half-adder")
		)
	)
	(dual-rail-full-adder-primed
		(case logic-type
			(("ncl") "dual-rail-full-adder-primed-ncl")
			(("balanced") "dual-rail-full-adder-primed-bal")
			(else "dual-rail-full-adder-primed")
		)
	)
	(dual-rail-full-adder
		(case logic-type
			(("dims") "dual-rail-dims-adder")
			(("ncl") "dual-rail-ncl-adder")
			(("balanced") "dual-rail-full-adder-bal")
			(else "dual-rail-full-adder")
		)
	)
	;define tree-building macros (for comparators)
	(binary-tree-macro (lambda (cell width input-index o-node inp0 inp1 int0 int1)
		(let
			((cell-name (eval cell))
			 (input-count (eval width))
			)
			(if (= 1 input-count)
				`(gates
					(connect (slice ,input-index 1 ,inp1)
						(slice ,o-node 1 ,int1)
					)
					(connect (slice ,input-index 1 ,inp0)
						(slice ,o-node 1 ,int0)
					)
				)
				(if (= 2 input-count)
					`(cell ,cell-name
						 (slice ,input-index 1 ,inp0)
						 (slice ,input-index 1 ,inp1)
						 (slice (+ 1 ,input-index) 1 ,inp0)
						 (slice (+ 1 ,input-index) 1 ,inp1)
						 (slice ,o-node 1 ,int0)
						 (slice ,o-node 1 ,int1)
					)
					(if (= 3 input-count)
						(let
							((half-conns (quotient input-count 2))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(cell ,cell-name
									(slice ,input-index 1 ,inp0)
									(slice ,input-index 1 ,inp1)
									(slice ,right-node 1 ,int0)
									(slice ,right-node 1 ,int1)
									(slice ,o-node 1 ,int0)
									(slice ,o-node 1 ,int1)
								)
								(macro binary-tree-macro ,cell-name ,right-count ,right-index ,right-node ,inp0 ,inp1 ,int0 ,int1)
							)
						)
						(let
							((half-conns (quotient input-count 2))
							 (left-node (+ o-node 1))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(cell ,cell-name
									(slice ,left-node 1 ,int0)
									(slice ,left-node 1 ,int1)
									(slice ,right-node 1 ,int0)
									(slice ,right-node 1 ,int1)
									(slice ,o-node 1 ,int0)
									(slice ,o-node 1 ,int1)
								)
								(macro binary-tree-macro ,cell-name ,half-conns ,input-index ,left-node ,inp0 ,inp1 ,int0 ,int1)
								(macro binary-tree-macro ,cell-name ,right-count ,right-index ,right-node ,inp0 ,inp1 ,int0 ,int1)
							)
						)
					)
				)
			)
		)
	))
	(mixed-binary-tree-macro (lambda (cellA cellB width input-index o-node inpA0 inpA1 inpB0 inpB1 intA0 intA1 intB0 intB1)
		(let
			((cellA-name (eval cellA))
			 (cellB-name (eval cellB))
			 (input-count (eval width))
			)
			(if (= 1 input-count)
				`(gates
					(connect (slice ,input-index 1 ,inpA0)
						(slice ,o-node 1 ,intA0)
					)
					(connect (slice ,input-index 1 ,inpA1)
						(slice ,o-node 1 ,intA1)
					)
				)
				(if (= 2 input-count)
					(if (= 0 input-index)
						`(cell ,cellA-name
							(slice 0 1 ,inpA0)
							(slice 0 1 ,inpA1)
							(slice 0 1 ,inpB0)
							(slice 0 1 ,inpB1)
							(slice 1 1 ,inpA0)
							(slice 1 1 ,inpA1)
							(slice ,o-node 1 ,intA0)
							(slice ,o-node 1 ,intA1)
						)
						`(cell ,cellB-name
							(slice (+ 1 ,input-index) 1 ,inpA0)
							(slice (+ 1 ,input-index) 1 ,inpA1)
							(slice ,input-index 1 ,inpB0)
							(slice ,input-index 1 ,inpB1)
							(slice ,input-index 1 ,inpA0)
							(slice ,input-index 1 ,inpA1)
							(slice (- ,input-index 1) 1 ,inpB0)
							(slice (- ,input-index 1) 1 ,inpB1)
							(slice ,o-node 1 ,intA0)
							(slice ,o-node 1 ,intA1)
							(slice (- ,full-add-width ,o-node 2) 1 ,intB0)
							(slice (- ,full-add-width ,o-node 2) 1 ,intB1)
						)
					)
					(if (= 3 input-count)
						(let
							((half-conns (quotient input-count 2))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(if (= 0 ,input-index)
									(cell ,cellA-name
										(slice 0 1 ,inpA0)
										(slice 0 1 ,inpA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
									)
									(cell ,cellB-name
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,input-index 1 ,inpA0)
										(slice ,input-index 1 ,inpA1)
										(slice (- ,input-index 1) 1 ,inpB0)
										(slice (- ,input-index 1) 1 ,inpB1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB1)
									)
								)
								(macro mixed-binary-tree-macro ,cellA-name ,cellB-name ,right-count ,right-index ,right-node ,inpA0 ,inpA1 ,inpB0 ,inpB1 ,intA0 ,intA1 ,intB0 ,intB1)
							)
						)
						(let
							((half-conns (quotient input-count 2))
							 (left-node (+ o-node 1))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(if (= 0 ,input-index)
									(cell ,cellA-name
										(slice ,left-node 1 ,intA0)
										(slice ,left-node 1 ,intA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
									)
									(cell ,cellB-name
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,left-node 1 ,intA0)
										(slice ,left-node 1 ,intA1)
										(slice (- ,full-add-width ,left-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,left-node 2) 1 ,intB1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB1)
									)
								)
								(macro mixed-binary-tree-macro ,cellA-name ,cellB-name ,half-conns ,input-index ,left-node ,inpA0 ,inpA1 ,inpB0 ,inpB1 ,intA0 ,intA1 ,intB0 ,intB1)
								(macro mixed-binary-tree-macro ,cellA-name ,cellB-name ,right-count ,right-index ,right-node ,inpA0 ,inpA1 ,inpB0 ,inpB1 ,intA0 ,intA1 ,intB0 ,intB1)
							)
						)
					)
				)
			)
		)
	))
	(dual-rail-orN (lambda (width inp0 inp1 out0 out1)
		`(gates
			(macro binary-tree-macro dual-rail-or2 ,width 0 0 ,inp0 ,inp1 (node "internalA0") (node "internalA1"))
			(connect (slice 0 1 (node "internalA0")) (slice 0 1 ,out0))
			(connect (slice 0 1 (node "internalA1")) (slice 0 1 ,out1))
		)
	))
	(ineq-comp-tree (lambda (width inpA0 inpA1 inpB0 inpB1 out0 out1)
		`(gates
			(macro mixed-binary-tree-macro dual-rail-ao21 dual-rail-ineq-comp ,width 0 0 ,inpA0 ,inpA1 ,inpB0 ,inpB1 (node "internalA0") (node "internalA1") (node "internalB0") (node "internalB1"))
			(connect (slice 0 1 (node "internalA0")) (slice 0 1 ,out0))
			(connect (slice 0 1 (node "internalA1")) (slice 0 1 ,out1))
		)
	))
)
(nodes
	("n1" (if logical-op n-width full-add-width) 0 1)
	("n0" (if logical-op n-width full-add-width) 0 1)
	("w1" (if logical-op w-width full-add-width) 0 1)
	("w0" (if logical-op w-width full-add-width) 0 1)
	("compOut1" (if (or equality-op inequality-op) full-add-width 0) 0 1)
	("compOut0" (if (or equality-op inequality-op) full-add-width 0) 0 1)
	("c1" (if arith-op (if (> out-extend-width 0) (+ full-add-width 1) full-add-width)
		  (if inequality-op (- full-add-width 1) 0)) 0 1)
	("c0" (if arith-op (if (> out-extend-width 0) (+ full-add-width 1) full-add-width)
		  (if inequality-op (- full-add-width 1) 0)) 0 1)
	("v1" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("v0" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("s1" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("s0" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("msbHa1" (if (and arith-op (= out-extend-width 0) (or (= 0 n-extend-width) n-signed)) 1 0) 0 1)
	("msbHa0" (if (and arith-op (= out-extend-width 0) (or (= 0 n-extend-width) n-signed)) 1 0) 0 1)
	("internalA1" (if (or equality-op inequality-op) (if (> full-add-width 1) (- full-add-width 1) 1) 0) 0 1)
	("internalA0" (if (or equality-op inequality-op) (if (> full-add-width 1) (- full-add-width 1) 1) 0) 0 1)
	("internalB1" (if inequality-op (- full-add-width 1) 0) 0 1)
	("internalB0" (if inequality-op (- full-add-width 1) 0) 0 1)
)
(gates
	(connect (req "out") (req "inpA") (req "inpB"))
	; setup wide input
	(if a-is-widest
		(if lt-inequality-op
			; invert inpA
			(gates
				(connect (slice 0 w-width (ack1 "inpA")) (slice 0 w-width (node "w0")))
				(connect (slice 0 w-width (ack0 "inpA")) (slice 0 w-width (node "w1")))
			)
			(gates
				(connect (slice 0 w-width (ack1 "inpA")) (slice 0 w-width (node "w1")))
				(connect (slice 0 w-width (ack0 "inpA")) (slice 0 w-width (node "w0")))
			)
		)
		(if (or subtractive-op gt-inequality-op)
			; invert inpB
			(gates
				(connect (slice 0 w-width (ack1 "inpB")) (slice 0 w-width (node "w0")))
				(connect (slice 0 w-width (ack0 "inpB")) (slice 0 w-width (node "w1")))
			)
			(gates
				(connect (slice 0 w-width (ack1 "inpB")) (slice 0 w-width (node "w1")))
				(connect (slice 0 w-width (ack0 "inpB")) (slice 0 w-width (node "w0")))
			)
		)
	)
	; setup narrow input
	(if a-is-widest
		(if (or subtractive-op gt-inequality-op)
			; invert inpB
			(gates
				(connect (slice 0 n-width (ack1 "inpB")) (slice 0 n-width (node "n0")))
				(connect (slice 0 n-width (ack0 "inpB")) (slice 0 n-width (node "n1")))
			)
			(gates
				(connect (slice 0 n-width (ack1 "inpB")) (slice 0 n-width (node "n1")))
				(connect (slice 0 n-width (ack0 "inpB")) (slice 0 n-width (node "n0")))
			)
		)
		(if lt-inequality-op
			; invert inpA
			(gates
				(connect (slice 0 n-width (ack1 "inpA")) (slice 0 n-width (node "n0")))
				(connect (slice 0 n-width (ack0 "inpA")) (slice 0 n-width (node "n1")))
			)
			(gates
				(connect (slice 0 n-width (ack1 "inpA")) (slice 0 n-width (node "n1")))
				(connect (slice 0 n-width (ack0 "inpA")) (slice 0 n-width (node "n0")))
			)
		)
	)
	; extend inputs (if not logical operation)
	(if (not logical-op)
		(gates 
			; sign-extend signed narrow input, if needed
			; unsigned narrow inputs are not extended, simpler operators are used
			(if (and (< 0 n-extend-width) n-signed)
				(gates
					(connect (slice (- n-width 1) 1 (node "n1"))
						 (smash (slice n-width n-extend-width (node "n1")))
					)
					(connect (slice (- n-width 1) 1 (node "n0"))
						 (smash (slice n-width n-extend-width (node "n0")))
					)
				)
			)
			; extend wide input, if needed (signed-unsigned ops)
			(if signed-unsigned-op
				(if w-signed
					; sign-extend operand
					(gates
						(connect (slice (- w-width 1) 1 (node "w1")) (slice w-width 1 (node "w1")))
						(connect (slice (- w-width 1) 1 (node "w0")) (slice w-width 1 (node "w0")))
					)
					; extend unsigned operand
					(if (and (not a-is-widest) subtractive-op) ; ~inpB connected to w
						; extend with 1s
						(gates
							(connect (req "out") (slice w-width 1 (node "w1")))
							(gnd (slice w-width 1 (node "w0")))
						)
						; extend with 0s
						(gates
							(gnd (slice w-width 1 (node "w1")))
							(connect (req "out") (slice w-width 1 (node "w0")))
						)
					)
				)
			)
		)
	)
	(cond
		(logical-op
			(case (param "op")
				(("And")
					(cell dual-rail-and2
						(slice 0 n-width (node "n0"))
						(slice 0 n-width (node "n1"))
						(slice 0 n-width (node "w0"))
						(slice 0 n-width (node "w1"))
						(slice 0 n-width (ack0 "out"))
						(slice 0 n-width (ack1 "out"))
					)
					(if (> output-width n-width)
					    ; if output is wider than n extend output with 0s
						(gates
							(gnd (smash (slice n-width (- output-width n-width) (ack1 "out"))))
							(connect (req "out") (smash (slice n-width (- output-width n-width) (ack0 "out"))))
						)
					)
				)
				(("Or" "Xor")
					(case (param "op")
						(("Or")
							(cell dual-rail-or2
								(slice 0 n-width (node "n0"))
								(slice 0 n-width (node "n1"))
								(slice 0 n-width (node "w0"))
								(slice 0 n-width (node "w1"))
								(slice 0 n-width (ack0 "out"))
								(slice 0 n-width (ack1 "out"))
							)
						)
						(("Xor")
							(cell dual-rail-xor2
								(slice 0 n-width (node "n0"))
								(slice 0 n-width (node "n1"))
								(slice 0 n-width (node "w0"))
								(slice 0 n-width (node "w1"))
								(slice 0 n-width (ack0 "out"))
								(slice 0 n-width (ack1 "out"))
							)
						)
					)
					(if (< 0 n-extend-width)
						; if w is wider than n extend output with w
						(gates
							(connect (slice n-width n-extend-width (node "w1")) 
								(slice n-width n-extend-width (ack1 "out"))
							)
							(connect (slice n-width n-extend-width (node "w0")) 
								(slice n-width n-extend-width (ack0 "out"))
							)
						)
					)
					(if (< 0 out-extend-width)
						; if output is wider than w extend output with 0s
					    (gates
							(gnd (smash (slice w-width out-extend-width (ack1 "out"))))
							(connect (req "out") (smash (slice w-width out-extend-width (ack0 "out"))))
						)
					)
				)
			)
		)
		(arith-op
			; if n operand is narrower and unsigned use narrow adder and extend with incrementer
			(if (and (< 0 n-extend-width) (not n-signed))
				(gates
					(cell dual-rail-full-adder
						(slice 0 n-width (node "n0"))
						(slice 0 n-width (node "n1"))
						(slice 0 n-width (node "w0"))
						(slice 0 n-width (node "w1"))
						(slice 0 n-width (node "c0"))
						(slice 0 n-width (node "c1"))
						(slice 1 n-width (node "c0"))
						(slice 1 n-width (node "c1"))
						(slice 0 n-width (ack0 "out"))
						(slice 0 n-width (ack1 "out"))
					)
					(if (or (not subtractive-op) (not a-is-widest))
						; either not a subtraction or inpA connected to n
						; channel n would be extended with 0s
						(cell dual-rail-half-adder
							(slice n-width (- n-extend-width 1) (node "w0"))
							(slice n-width (- n-extend-width 1) (node "w1"))
							(slice n-width (- n-extend-width 1) (node "c0"))
							(slice n-width (- n-extend-width 1) (node "c1"))
							(slice (+ 1 n-width) (- n-extend-width 1) (node "c0"))
							(slice (+ 1 n-width) (- n-extend-width 1) (node "c1"))
							(slice n-width (- n-extend-width 1) (ack0 "out"))
							(slice n-width (- n-extend-width 1) (ack1 "out"))
						)
						; a subtraction and ~inpB connected to n
						; channel n would be extended with 1s
						(cell dual-rail-full-adder-primed
							(slice n-width (- n-extend-width 1) (node "w0"))
							(slice n-width (- n-extend-width 1) (node "w1"))
							(slice n-width (- n-extend-width 1) (node "c0"))
							(slice n-width (- n-extend-width 1) (node "c1"))
							(slice (+ 1 n-width) (- n-extend-width 1) (node "c0"))
							(slice (+ 1 n-width) (- n-extend-width 1) (node "c1"))
							(slice n-width (- n-extend-width 1) (ack0 "out"))
							(slice n-width (- n-extend-width 1) (ack1 "out"))
						)
					)
					(if (< 0 out-extend-width)
						; generate out carry
						(if (or (not subtractive-op) (not a-is-widest))
							; either not a subtraction or inpA connected to n
							; channel n would be extended with 0s
							(cell dual-rail-half-adder
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice (- full-add-width 1) 1 (node "c0"))
								(slice (- full-add-width 1) 1 (node "c1"))
								(slice full-add-width 1 (node "c0"))
								(slice full-add-width 1 (node "c1"))
								(slice (- full-add-width 1) 1 (ack0 "out"))
								(slice (- full-add-width 1) 1 (ack1 "out"))
							)
							; a subtraction and ~inpB connected to n
							; channel n would be extended with 1s
							(cell dual-rail-full-adder-primed
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice (- full-add-width 1) 1 (node "c0"))
								(slice (- full-add-width 1) 1 (node "c1"))
								(slice full-add-width 1 (node "c0"))
								(slice full-add-width 1 (node "c1"))
								(slice (- full-add-width 1) 1 (ack0 "out"))
								(slice (- full-add-width 1) 1 (ack1 "out"))
							)
						)
						; no need to generate out carry
						(if (or (not subtractive-op) (not a-is-widest))
							; either not a subtraction or inpA connected to n
							; channel n would be extended with 0s
							(cell dual-rail-xor2
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice (- full-add-width 1) 1 (node "c0"))
								(slice (- full-add-width 1) 1 (node "c1"))
								(slice (- full-add-width 1) 1 (ack0 "out"))
								(slice (- full-add-width 1) 1 (ack1 "out"))
							)
							; a subtraction and ~inpB connected to n
							; channel n would be extended with 1s
							(cell dual-rail-xor2
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice (- full-add-width 1) 1 (node "c0"))
								(slice (- full-add-width 1) 1 (node "c1"))
								(slice (- full-add-width 1) 1 (ack1 "out"))
								(slice (- full-add-width 1) 1 (ack0 "out"))
							)
						)
					)
				)
				(gates
					(cell dual-rail-full-adder
						(slice 0 (- full-add-width 1) (node "n0"))
						(slice 0 (- full-add-width 1) (node "n1"))
						(slice 0 (- full-add-width 1) (node "w0"))
						(slice 0 (- full-add-width 1) (node "w1"))
						(slice 0 (- full-add-width 1) (node "c0"))
						(slice 0 (- full-add-width 1) (node "c1"))
						(slice 1 (- full-add-width 1) (node "c0"))
						(slice 1 (- full-add-width 1) (node "c1"))
						(slice 0 (- full-add-width 1) (ack0 "out"))
						(slice 0 (- full-add-width 1) (ack1 "out"))
					)
					(if (< 0 out-extend-width)
						; produce out carry
						(cell dual-rail-full-adder
							(slice (- full-add-width 1) 1 (node "n0"))
							(slice (- full-add-width 1) 1 (node "n1"))
							(slice (- full-add-width 1) 1 (node "w0"))
							(slice (- full-add-width 1) 1 (node "w1"))
							(slice (- full-add-width 1) 1 (node "c0"))
							(slice (- full-add-width 1) 1 (node "c1"))
							(slice full-add-width 1 (node "c0"))
							(slice full-add-width 1 (node "c1"))
							(slice (- full-add-width 1) 1 (ack0 "out"))
							(slice (- full-add-width 1) 1 (ack1 "out"))
						)
						; no need to produce out carry
						(gates
							(cell dual-rail-xor2
								(slice (- full-add-width 1) 1 (node "n0"))
								(slice (- full-add-width 1) 1 (node "n1"))
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice 0 1 (node "msbHa0"))
								(slice 0 1 (node "msbHa1"))
							)
							(cell dual-rail-xor2
								(slice 0 1 (node "msbHa0"))
								(slice 0 1 (node "msbHa1"))
								(slice (- full-add-width 1) 1 (node "c0"))
								(slice (- full-add-width 1) 1 (node "c1"))
								(slice (- full-add-width 1) 1 (ack0 "out"))
								(slice (- full-add-width 1) 1 (ack1 "out"))
							)
						)
					)
				)
			)
			; set input carry to 0 ("Add") or 1 ("Subtract")
			(if subtractive-op
				(gates
					(connect (req "out") (slice 0 1 (node "c1")))
					(gnd (slice 0 1 (node "c0")))
				)
				(gates
					(gnd (slice 0 1 (node "c1")))
					(connect (req "out") (slice 0 1 (node "c0")))
				)
			)
			; extend output if needed
			(if (< 0 out-extend-width)
				(if signed-op
					; sign-extend output 
					; (use overflow (V) and adder output MSB [V xor MSB] for correct sign)
					(gates
						(cell dual-rail-xor2
							(slice (- full-add-width 1) 1 (node "c0"))
							(slice (- full-add-width 1) 1 (node "c1"))
							(slice full-add-width 1 (node "c0"))
							(slice full-add-width 1 (node "c1"))
							(node "v0")
							(node "v1")
						)
						(cell dual-rail-xor2
							(node "v0")
							(node "v1")
							(slice (- full-add-width 1) 1 (ack0 "out"))
							(slice (- full-add-width 1) 1 (ack1 "out"))
							(node "s0")
							(node "s1")
						)
						(connect (node "s1") (smash (slice full-add-width 
							out-extend-width (ack1 "out")))
						)
						(connect (node "s0") (smash (slice full-add-width 
							out-extend-width (ack0 "out")))
						)
					)
					; unsigned: extend is different for "Add" and "Subtract"
					(if subtractive-op
						; "Subtract": extend with ~carry
						(gates
							(connect (slice full-add-width 1 (node "c1")) 
									 (smash (slice full-add-width out-extend-width (ack0 "out")))
							)
							(connect (slice full-add-width 1 (node "c0")) 
									 (smash (slice full-add-width out-extend-width (ack1 "out")))
							)
						)
						; "Add": extend first bit with carry and more bits with 0s
						(gates
							(connect (slice full-add-width 1 (node "c1")) 
									 (slice full-add-width 1 (ack1 "out"))
							)
							(connect (slice full-add-width 1 (node "c0")) 
									 (slice full-add-width 1 (ack0 "out"))
							)
							(if (< 1 out-extend-width)
								(gates
									(gnd (smash (slice (+ full-add-width 1)
										 (- out-extend-width 1) (ack1 "out")))
									)
									(connect (req "out") (smash (slice (+ full-add-width 1)
											 (- out-extend-width 1) (ack0 "out")))
									)
								)
							)
						)
					)
				)
			)
		)
		(inequality-op
			; if channel n operand is unsigned it would be extended with 0s or 1s
			; use only n-width comp and extend with simpler circuit
			(if (and (< 0 n-extend-width) (not n-signed))
				(gates
					; bit 0
					(cell dual-rail-and2
						(slice 0 1 (node "n0"))
						(slice 0 1 (node "n1"))
						(slice 0 1 (node "w0"))
						(slice 0 1 (node "w1"))
						(slice 0 1 (node "compOut0"))
						(slice 0 1 (node "compOut1"))
					)
					; bit 1 to bit n-width-1
					(if	(> n-width 1)
						(cell dual-rail-half-adder
							(slice 1 (- n-width 1) (node "n0"))
							(slice 1 (- n-width 1) (node "n1"))
							(slice 1 (- n-width 1) (node "w0"))
							(slice 1 (- n-width 1) (node "w1"))
							(slice 1 (- n-width 1) (node "compOut0"))
							(slice 1 (- n-width 1) (node "compOut1"))
							(slice 0 (- n-width 1) (node "c0"))
							(slice 0 (- n-width 1) (node "c1"))
						)
					)
					; bit n-width to bit n-width+n-extend-width-2
					(if (> n-extend-width 1)
						(if (or (and a-is-widest gt-inequality-op)
								(and (not a-is-widest) lt-inequality-op)
							) 
							; n should be extended with 1s
							(gates
								(connect (slice n-width (- n-extend-width 1) (node "w0"))
									(slice n-width (- n-extend-width 1) (node "compOut0"))
								)
								(connect (slice n-width (- n-extend-width 1) (node "w1"))
									(slice n-width (- n-extend-width 1) (node "compOut1"))
								)
								(connect (slice n-width (- n-extend-width 1) (node "w0"))
									(slice (- n-width 1) (- n-extend-width 1) (node "c1"))
								)
								(connect (slice n-width (- n-extend-width 1) (node "w1"))
									(slice (- n-width 1) (- n-extend-width 1) (node "c0"))
								)
							)
							; n should be extended with 0s
							(gates
								(connect (req "out")
									(smash (slice n-width (- n-extend-width 1) (node "compOut0")))
								)
								(gnd (smash (slice n-width (- n-extend-width 1) (node "compOut1"))))
								(connect (slice n-width (- n-extend-width 1) (node "w0"))
									(slice (- n-width 1) (- n-extend-width 1) (node "c0"))
								)
								(connect (slice n-width (- n-extend-width 1) (node "w1"))
									(slice (- n-width 1) (- n-extend-width 1) (node "c1"))
								)
							)
						)
					)
					; bit full-add-width-1 (n-width+n-extend-width-1)
					(if signed-op           ; invert sign bits
						(if (or (and a-is-widest gt-inequality-op)
								(and (not a-is-widest) lt-inequality-op)
							) 
							; n should be extended with 0s and invert w
							(gates
								(connect (req "out")
									(slice (- full-add-width 1) 1 (node "compOut0"))
								)
								(gnd (slice (- full-add-width 1) 1 (node "compOut1")))
								(connect (slice (- full-add-width 1) 1 (node "w1"))
									(slice (- full-add-width 2) 1 (node "c0"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w0"))
									(slice (- full-add-width 2) 1 (node "c1"))
								)
							)
							; n should be extended with 1s and invert w
							(gates
								(connect (slice (- full-add-width 1) 1 (node "w1"))
									(slice (- full-add-width 1) 1 (node "compOut0"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w0"))
									(slice (- full-add-width 1) 1 (node "compOut1"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w1"))
									(slice (- full-add-width 2) 1 (node "c1"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w0"))
									(slice (- full-add-width 2) 1 (node "c0"))
								)
							)
						)
						(if (or (and a-is-widest gt-inequality-op)
								(and (not a-is-widest) lt-inequality-op)
							) 
							; n should be extended with 1s
							(gates
								(connect (slice (- full-add-width 1) 1 (node "w0"))
									(slice (- full-add-width 1) 1 (node "compOut0"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w1"))
									(slice (- full-add-width 1) 1 (node "compOut1"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w0"))
									(slice (- full-add-width 2) 1 (node "c1"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w1"))
									(slice (- full-add-width 2) 1 (node "c0"))
								)
							)
							; n should be extended with 0s
							(gates
								(connect (req "out")
									(slice (- full-add-width 1) 1 (node "compOut0"))
								)
								(gnd (slice (- full-add-width 1) 1 (node "compOut1")))
								(connect (slice (- full-add-width 1) 1 (node "w0"))
									(slice (- full-add-width 2) 1 (node "c0"))
								)
								(connect (slice (- full-add-width 1) 1 (node "w1"))
									(slice (- full-add-width 2) 1 (node "c1"))
								)
							)
						)
					)
				)
				(gates
					; bit 0
					(if (and (= full-add-width 1) signed-op) ; invert sign bits
						(cell dual-rail-and2
							(slice 0 1 (node "n1"))
							(slice 0 1 (node "n0"))
							(slice 0 1 (node "w1"))
							(slice 0 1 (node "w0"))
							(slice 0 1 (node "compOut0"))
							(slice 0 1 (node "compOut1"))
						)
						(cell dual-rail-and2
							(slice 0 1 (node "n0"))
							(slice 0 1 (node "n1"))
							(slice 0 1 (node "w0"))
							(slice 0 1 (node "w1"))
							(slice 0 1 (node "compOut0"))
							(slice 0 1 (node "compOut1"))
						)
					)
					; bit 1 to bit full-add-width-2
					(if	(> full-add-width 2)
						(cell dual-rail-half-adder
							(slice 1 (- full-add-width 2) (node "n0"))
							(slice 1 (- full-add-width 2) (node "n1"))
							(slice 1 (- full-add-width 2) (node "w0"))
							(slice 1 (- full-add-width 2) (node "w1"))
							(slice 1 (- full-add-width 2) (node "compOut0"))
							(slice 1 (- full-add-width 2) (node "compOut1"))
							(slice 0 (- full-add-width 2) (node "c0"))
							(slice 0 (- full-add-width 2) (node "c1"))
						)
					)
					; bit full-add-width-1
					(if (> full-add-width 1)
						(if signed-op           ; invert sign bits
							(cell dual-rail-half-adder
								(slice (- full-add-width 1) 1 (node "n1"))
								(slice (- full-add-width 1) 1 (node "n0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "compOut0"))
								(slice (- full-add-width 1) 1 (node "compOut1"))
								(slice (- full-add-width 2) 1 (node "c0"))
								(slice (- full-add-width 2) 1 (node "c1"))
							)
							(cell dual-rail-half-adder
								(slice (- full-add-width 1) 1 (node "n0"))
								(slice (- full-add-width 1) 1 (node "n1"))
								(slice (- full-add-width 1) 1 (node "w0"))
								(slice (- full-add-width 1) 1 (node "w1"))
								(slice (- full-add-width 1) 1 (node "compOut0"))
								(slice (- full-add-width 1) 1 (node "compOut1"))
								(slice (- full-add-width 2) 1 (node "c0"))
								(slice (- full-add-width 2) 1 (node "c1"))
							)
						)
					)
				)
			)
			(case (param "op")
				(("LessThan" "GreaterThan")
					(macro ineq-comp-tree
						full-add-width
						(node "compOut0")
						(node "compOut1")
						(node "c0")
						(node "c1")
						(ack0 "out")
						(ack1 "out")
					)
				)
				(("GreaterOrEquals" "LessOrEquals")
					(macro ineq-comp-tree  ;; invert out
						full-add-width
						(node "compOut0")
						(node "compOut1")
						(node "c0")
						(node "c1")
						(ack1 "out")
						(ack0 "out")
					)
				)
			)
		)
		(equality-op
			; if channel n operand is unsigned it would be extended with 0s.
			; use only n-width xor gates and extend with channel w (w xor 0 = w).
			(if (and (< 0 n-extend-width) (not n-signed))
				(gates
					(cell dual-rail-xor2
						(slice 0 n-width (node "n0"))
						(slice 0 n-width (node "n1"))
						(slice 0 n-width (node "w0"))
						(slice 0 n-width (node "w1"))
						(slice 0 n-width (node "compOut0"))
						(slice 0 n-width (node "compOut1"))
					)
					(connect (slice n-width n-extend-width (node "w1"))
						(slice n-width n-extend-width (node "compOut1"))
					)
					(connect (slice n-width n-extend-width (node "w0"))
						(slice n-width n-extend-width (node "compOut0"))
					)
				)
				(cell dual-rail-xor2
					(node "n0")
					(node "n1")
					(node "w0")
					(node "w1")
					(node "compOut0")
					(node "compOut1")
				)
			)
			(case (param "op")
				(("Equals")
					(macro dual-rail-orN   ;; invert out (dual-rail-norN)
						full-add-width
						(node "compOut0")
						(node "compOut1")
						(ack1 "out")
						(ack0 "out")
					)
				)
				(("NotEquals")
					(macro dual-rail-orN
						full-add-width
						(node "compOut0")
						(node "compOut1")
						(ack0 "out")
						(ack1 "out")
					)
				)
			)
		)
	)
)
