(defines
	; operation types
	(logical-op (case (param "op") (("And" "Or" "Xor") #t) (else #f)))
	(arith-op (case (param "op") (("Add" "Subtract" "ReverseSubtract") #t) (else #f)))
	(reverse-subtract-op (= (param "op") "ReverseSubtract"))
	(subtractive-op (or (= (param "op") "Subtract") reverse-subtract-op))
	(equality-op (case (param "op") (("Equals" "NotEquals") #t) (else #f)))
	(lt-inequality-op
		(case (param "op")
			  (("LessThan" "GreaterOrEquals") #t)
			  (else #f)
		)
	)
	(gt-inequality-op
		(case (param "op")
			  (("GreaterThan" "LessOrEquals") #t)
			  (else #f)
		)
	)
	(inequality-op
		(case (param "op")
			  (("LessThan" "GreaterThan" "LessOrEquals" "GreaterOrEquals") #t)
			  (else #f)
		)
	)
	; widths and signedness of wide and narrow inputs
	(output-width (param "outputWidth"))
	(max-input-width (max (param "inputAWidth") (param "inputBWidth")))
	(max-width
		(if (or equality-op inequality-op) max-input-width
			(min output-width max-input-width)
		)
	)
	(a-width (min max-width (param "inputAWidth")))
	(b-width (min max-width (param "inputBWidth")))
	(a-is-widest (>= a-width b-width))
	(a-signed (= "true" (param "inputAIsSigned")))
	(b-signed (= "true" (param "inputBIsSigned")))
	(w-width (if a-is-widest a-width b-width))
	(w-signed (if a-is-widest a-signed b-signed))
	(n-width (if a-is-widest b-width a-width))
	(n-signed (if a-is-widest b-signed a-signed))
	(signed-op (or n-signed w-signed))
	; doing signed x unsigned need to extend range of the unsigned input
	; giving an extra bit to the output if the unsigned number is
	; larger or equal in length to the signed number
	(signed-unsigned-op
		(and (not logical-op)
			(or (not arith-op) (> output-width w-width)) 
			(/= w-signed n-signed)
			(or (not w-signed) ; unsigned is largest or equal
				(and w-signed (= w-width n-width)) ; unsigned is equal
			)
		)
	)
	(full-add-width (+ (if signed-unsigned-op 1 0) w-width))
	(n-extend-width (- full-add-width n-width))
	(out-extend-width (- output-width full-add-width))
	(input-value (param "inputBValue"))
	; compute input-value with full-add-width bits (NOTE: can grow or shrink in width)
	(input-value-fa-width-pre
		(if (>= full-add-width (param "inputBWidth"))
			; if inputB is narrower: if it is signed then extend input-value with 1s else extend with 0s
			; note that constants are sent as signed ONLY when negative.
			(if b-signed (+ (- (expt 2 full-add-width) (expt 2 b-width)) input-value) input-value)
			; if inputB is wider: chop off high bits
			(- input-value (* (expt 2 full-add-width) (/ input-value (expt 2 full-add-width))))
		)
	)
	; complement input-value if subtract or gt-inequality operation
	(input-value-fa-width (if (or (= (param "op") "Subtract") gt-inequality-op)
						  (- (expt 2 full-add-width) input-value-fa-width-pre 1) input-value-fa-width-pre))
    (not-input-value-fa-width (- (expt 2 full-add-width) 1 input-value-fa-width))
	; compute input-value with a-width bits (NOTE: can grow or shrink in width)
	(input-value-a-width
		(if (>= a-width (param "inputBWidth"))
			; if inputB is narrower: if it is signed then extend input-value with 1s else extend with 0s
			; note that constants are sent as signed ONLY when negative.
			(if b-signed (+ (- (expt 2 a-width) (expt 2 b-width)) input-value) input-value)
			; if inputB is wider: chop off high bits
			(- input-value (* (expt 2 a-width) (/ input-value (expt 2 a-width))))
		)
	)
    (not-input-value-a-width (- (expt 2 a-width) 1 input-value-a-width))
    ; compute input-value for adders (msb = 0)
	(input-value-adder
		(if (>= input-value-fa-width (expt 2 (- full-add-width 1)))
			(- input-value-fa-width (expt 2 (- full-add-width 1)))
			input-value-fa-width
		)
	)
	(not-input-value-adder
		(if (>= not-input-value-fa-width (expt 2 (- full-add-width 1)))
			(- not-input-value-fa-width (expt 2 (- full-add-width 1)))
			not-input-value-fa-width
		)
	)
    ; compute input-value for inequality comparators (with lsb = 0  and msb (sign bit) = 0)
	(input-value-ineq
		(* 2 
		    (/
				(if (>= input-value-fa-width (expt 2 (- full-add-width 1)))
					(- input-value-fa-width (expt 2 (- full-add-width 1)))
					input-value-fa-width
				)
				2
			)
		)
	)
	(not-input-value-ineq
		(* 2
		    (/
				(if (>= not-input-value-fa-width (expt 2 (- full-add-width 1)))
					(- not-input-value-fa-width (expt 2 (- full-add-width 1)))
					not-input-value-fa-width
				)
				2
			)
		)
	)
	(is-input-value-odd (/= input-value-fa-width (* 2 (/ input-value-fa-width 2))))
	; Define cells according to style options:
	(dual-rail-and2
		(case logic-type
			(("ncl") "dual-rail-and2-ncl")
			(("balanced") "dual-rail-and2-bal")
			(else "dual-rail-and2")
		)
	)
	(dual-rail-or2
		(case logic-type
			(("ncl") "dual-rail-or2-ncl")
			(("balanced") "dual-rail-or2-bal")
			(else "dual-rail-or2")
		)
	)
	(dual-rail-xor2
		(case logic-type
			(("ncl") "dual-rail-xor2-ncl")
			(else "dual-rail-xor2")
		)
	)
	(dual-rail-ao21
		(case logic-type
			(("ncl") "dual-rail-ao21-ncl")
			(("balanced") "dual-rail-ao21-bal")
			(else "dual-rail-ao21")
		)
	)
	(dual-rail-ineq-comp
		(case logic-type
			(("ncl") "dual-rail-ineq-comp-ncl")
			(("balanced") "dual-rail-ineq-comp-bal")
			(else "dual-rail-ineq-comp")
		)
	)
	(dual-rail-half-adder
		(case logic-type
			(("ncl") "dual-rail-half-adder-ncl")
			(("balanced") "dual-rail-half-adder-bal")
			(else "dual-rail-half-adder")
		)
	)
	(dual-rail-full-adder-primed
		(case logic-type
			(("ncl") "dual-rail-full-adder-primed-ncl")
			(("balanced") "dual-rail-full-adder-primed-bal")
			(else "dual-rail-full-adder-primed")
		)
	)
	;define tree-building macro (for comparators)
	(binary-tree-macro (lambda (cell width input-index o-node inp0 inp1 int0 int1)
		(let
			((cell-name (eval cell))
			 (input-count (eval width))
			)
			(if (= 1 input-count)
				`(gates
					(connect (slice ,input-index 1 ,inp1)
						(slice ,o-node 1 ,int1)
					)
					(connect (slice ,input-index 1 ,inp0)
						(slice ,o-node 1 ,int0)
					)
				)
				(if (= 2 input-count)
					`(cell ,cell-name
						 (slice ,input-index 1 ,inp0)
						 (slice ,input-index 1 ,inp1)
						 (slice (+ 1 ,input-index) 1 ,inp0)
						 (slice (+ 1 ,input-index) 1 ,inp1)
						 (slice ,o-node 1 ,int0)
						 (slice ,o-node 1 ,int1)
					)
					(if (= 3 input-count)
						(let
							((half-conns (quotient input-count 2))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(cell ,cell-name
									(slice ,input-index 1 ,inp0)
									(slice ,input-index 1 ,inp1)
									(slice ,right-node 1 ,int0)
									(slice ,right-node 1 ,int1)
									(slice ,o-node 1 ,int0)
									(slice ,o-node 1 ,int1)
								)
								(macro binary-tree-macro ,cell-name ,right-count ,right-index ,right-node ,inp0 ,inp1 ,int0 ,int1)
							)
						)
						(let
							((half-conns (quotient input-count 2))
							 (left-node (+ o-node 1))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(cell ,cell-name
									(slice ,left-node 1 ,int0)
									(slice ,left-node 1 ,int1)
									(slice ,right-node 1 ,int0)
									(slice ,right-node 1 ,int1)
									(slice ,o-node 1 ,int0)
									(slice ,o-node 1 ,int1)
								)
								(macro binary-tree-macro ,cell-name ,half-conns ,input-index ,left-node ,inp0 ,inp1 ,int0 ,int1)
								(macro binary-tree-macro ,cell-name ,right-count ,right-index ,right-node ,inp0 ,inp1 ,int0 ,int1)
							)
						)
					)
				)
			)
		)
	))
	(mixed-binary-tree-macro (lambda (cellA cellB width input-index o-node inpA0 inpA1 inpB0 inpB1 intA0 intA1 intB0 intB1)
		(let
			((cellA-name (eval cellA))
			 (cellB-name (eval cellB))
			 (input-count (eval width))
			)
			(if (= 1 input-count)
				`(gates
					(connect (slice ,input-index 1 ,inpA0)
						(slice ,o-node 1 ,intA0)
					)
					(connect (slice ,input-index 1 ,inpA1)
						(slice ,o-node 1 ,intA1)
					)
				)
				(if (= 2 input-count)
					(if (= 0 input-index)
						`(cell ,cellA-name
							(slice 0 1 ,inpA0)
							(slice 0 1 ,inpA1)
							(slice 0 1 ,inpB0)
							(slice 0 1 ,inpB1)
							(slice 1 1 ,inpA0)
							(slice 1 1 ,inpA1)
							(slice ,o-node 1 ,intA0)
							(slice ,o-node 1 ,intA1)
						)
						`(cell ,cellB-name
							(slice (+ 1 ,input-index) 1 ,inpA0)
							(slice (+ 1 ,input-index) 1 ,inpA1)
							(slice ,input-index 1 ,inpB0)
							(slice ,input-index 1 ,inpB1)
							(slice ,input-index 1 ,inpA0)
							(slice ,input-index 1 ,inpA1)
							(slice (- ,input-index 1) 1 ,inpB0)
							(slice (- ,input-index 1) 1 ,inpB1)
							(slice ,o-node 1 ,intA0)
							(slice ,o-node 1 ,intA1)
							(slice (- ,full-add-width ,o-node 2) 1 ,intB0)
							(slice (- ,full-add-width ,o-node 2) 1 ,intB1)
						)
					)
					(if (= 3 input-count)
						(let
							((half-conns (quotient input-count 2))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(if (= 0 ,input-index)
									(cell ,cellA-name
										(slice 0 1 ,inpA0)
										(slice 0 1 ,inpA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
									)
									(cell ,cellB-name
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,input-index 1 ,inpA0)
										(slice ,input-index 1 ,inpA1)
										(slice (- ,input-index 1) 1 ,inpB0)
										(slice (- ,input-index 1) 1 ,inpB1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB1)
									)
								)
								(macro mixed-binary-tree-macro ,cellA-name ,cellB-name ,right-count ,right-index ,right-node ,inpA0 ,inpA1 ,inpB0 ,inpB1 ,intA0 ,intA1 ,intB0 ,intB1)
							)
						)
						(let
							((half-conns (quotient input-count 2))
							 (left-node (+ o-node 1))
							 (right-count (- input-count half-conns))
							 (right-index (+ input-index half-conns))
							 (right-node (+ o-node half-conns))
							)
							`(gates
								(if (= 0 ,input-index)
									(cell ,cellA-name
										(slice ,left-node 1 ,intA0)
										(slice ,left-node 1 ,intA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
									)
									(cell ,cellB-name
										(slice ,right-node 1 ,intA0)
										(slice ,right-node 1 ,intA1)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,right-node 2) 1 ,intB1)
										(slice ,left-node 1 ,intA0)
										(slice ,left-node 1 ,intA1)
										(slice (- ,full-add-width ,left-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,left-node 2) 1 ,intB1)
										(slice ,o-node 1 ,intA0)
										(slice ,o-node 1 ,intA1)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB0)
										(slice (- ,full-add-width ,o-node 2) 1 ,intB1)
									)
								)
								(macro mixed-binary-tree-macro ,cellA-name ,cellB-name ,half-conns ,input-index ,left-node ,inpA0 ,inpA1 ,inpB0 ,inpB1 ,intA0 ,intA1 ,intB0 ,intB1)
								(macro mixed-binary-tree-macro ,cellA-name ,cellB-name ,right-count ,right-index ,right-node ,inpA0 ,inpA1 ,inpB0 ,inpB1 ,intA0 ,intA1 ,intB0 ,intB1)
							)
						)
					)
				)
			)
		)
	))
	(dual-rail-orN (lambda (width inp0 inp1 out0 out1)
		`(gates
			(macro binary-tree-macro dual-rail-or2 ,width 0 0 ,inp0 ,inp1 (node "internalA0") (node "internalA1"))
			(connect (slice 0 1 (node "internalA0")) (slice 0 1 ,out0))
			(connect (slice 0 1 (node "internalA1")) (slice 0 1 ,out1))
		)
	))
	(ineq-comp-tree (lambda (width inpA0 inpA1 inpB0 inpB1 out0 out1)
		`(gates
			(macro mixed-binary-tree-macro dual-rail-ao21 dual-rail-ineq-comp ,width 0 0 ,inpA0 ,inpA1 ,inpB0 ,inpB1 (node "internalA0") (node "internalA1") (node "internalB0") (node "internalB1"))
			(connect (slice 0 1 (node "internalA0")) (slice 0 1 ,out0))
			(connect (slice 0 1 (node "internalA1")) (slice 0 1 ,out1))
		)
	))
)
(nodes
	("a1" (if (and (not logical-op) (not equality-op)) full-add-width 0) 0 1)
	("a0" (if (and (not logical-op) (not equality-op)) full-add-width 0) 0 1)
	("compOut1" (if (or equality-op inequality-op) full-add-width 0) 0 1)
	("compOut0" (if (or equality-op inequality-op) full-add-width 0) 0 1)
	("c1" (if arith-op (if (> out-extend-width 0) (+ full-add-width 1) full-add-width)
		  (if inequality-op (- full-add-width 1) 0)) 0 1)
	("c0" (if arith-op (if (> out-extend-width 0) (+ full-add-width 1) full-add-width)
		  (if inequality-op (- full-add-width 1) 0)) 0 1)
	("v1" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("v0" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("s1" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("s0" (if (and arith-op signed-op (> out-extend-width 0)) 1 0) 0 1)
	("internalA1" (if (or equality-op inequality-op) (if (> full-add-width 1) (- full-add-width 1) 1) 0) 0 1)
	("internalA0" (if (or equality-op inequality-op) (if (> full-add-width 1) (- full-add-width 1) 1) 0) 0 1)
	("internalB1" (if inequality-op (- full-add-width 1) 0) 0 1)
	("internalB0" (if inequality-op (- full-add-width 1) 0) 0 1)
)
(gates
	(connect (req "out") (req "inpA"))
	; setup input a (only if not a logical operation and not an equality comparison)
	(if (and (not logical-op) (not equality-op))
		(gates
			(if (or reverse-subtract-op lt-inequality-op)
				; invert inpA
				(gates
					(connect (slice 0 (if a-is-widest w-width n-width) (ack1 "inpA"))
						(slice 0 (if a-is-widest w-width n-width) (node "a0"))
					)
					(connect (slice 0 (if a-is-widest w-width n-width) (ack0 "inpA"))
						(slice 0 (if a-is-widest w-width n-width) (node "a1"))
					)
				)
				(gates
					(connect (slice 0 (if a-is-widest w-width n-width) (ack1 "inpA"))
						(slice 0 (if a-is-widest w-width n-width) (node "a1"))
					)
					(connect (slice 0 (if a-is-widest w-width n-width) (ack0 "inpA"))
						(slice 0 (if a-is-widest w-width n-width) (node "a0"))
					)
				)
			)
			; extend narrow input, if inpA is narrower than inpB
			(if (and (< 0 n-extend-width) (not a-is-widest))
				(if n-signed
					; sign-extend signed operand
					(gates
						(connect (slice (- n-width 1) 1 (node "a1"))
							(smash (slice n-width n-extend-width (node "a1")))
						)
						(connect (slice (- n-width 1) 1 (node "a0"))
							(smash (slice n-width n-extend-width (node "a0")))
						)
					)
					; extend unsigned operand
					(if reverse-subtract-op
						; extend with 1s
						(gates
							(connect (req "out")
								(smash (slice n-width n-extend-width (node "a1")))
							)
							(gnd (smash (slice n-width n-extend-width (node "a0"))))
						)
						; extend with 0s
						(gates
							(gnd (smash (slice n-width n-extend-width (node "a1"))))
							(connect (req "out")
								(smash (slice n-width n-extend-width (node "a0")))
							)
						)
					)
				)
			)
			; extend wide input, if (signed-unsigned op) and inpA is wider than inpB
			(if (and signed-unsigned-op a-is-widest)
				(if w-signed
					; sign-extend operand
					(gates
						(connect (slice (- w-width 1) 1 (node "a1"))
							(slice w-width 1 (node "a1"))
						)
						(connect (slice (- w-width 1) 1 (node "a0"))
							(slice w-width 1 (node "a0"))
						)
					)
					; extend unsigned operand
					(if reverse-subtract-op
						; extend with 1s
						(gates
							(connect (req "out") (slice w-width 1 (node "a1")))
							(gnd (slice w-width 1 (node "a0")))
						)
						; extend with 0s
						(gates
							(gnd (slice w-width 1 (node "a1")))
							(connect (req "out") (slice w-width 1 (node "a0")))
						)
					)
				)
			)
		)
	)
	(cond
		(logical-op
			(case (param "op")
				(("And")
					(if (/= 0 input-value-a-width)
						(gates
							(connect (filter input-value-a-width (ack1 "inpA"))
								(filter input-value-a-width (ack1 "out"))
							)
							(connect (filter input-value-a-width (ack0 "inpA"))
								(filter input-value-a-width (ack0 "out"))
							)
						)
					)
					(if (/= 0 not-input-value-a-width)
						(gates
							(gnd (smash (filter not-input-value-a-width (ack1 "out"))))
							(connect (req "out")
								(smash (filter not-input-value-a-width (ack0 "out")))
							)
						)
					)
					; extend with 0s if constant is wider than inpA
					(if (> full-add-width a-width)
						(gates
							(gnd (smash (slice a-width (- full-add-width a-width) (ack1 "out"))))
							(connect (req "out")
								(smash (slice a-width (- full-add-width a-width) (ack0 "out")))
							)
						)
					)
				)
				(("Or")
					(if (/= 0 input-value-a-width)
						(gates
							(connect (req "out")
								(smash (filter input-value-a-width (ack1 "out")))
							)
							(gnd (smash (filter input-value-a-width (ack0 "out"))))
						)
					)
					(if (/= 0 not-input-value-a-width)
						(gates
							(connect (filter not-input-value-a-width (ack1 "inpA"))
								(filter not-input-value-a-width (ack1 "out"))
							)
							(connect (filter not-input-value-a-width (ack0 "inpA"))
								(filter not-input-value-a-width (ack0 "out"))
							)
						)
					)
					; extend with value of constant if it is wider than inpA
					(if (> full-add-width a-width)
						(gates
							(if (/= 0 (- input-value-fa-width input-value-a-width))
								(gates
									(connect (req "out")
										(smash (filter (- input-value-fa-width input-value-a-width) (ack1 "out")))
									)
									(gnd (smash (filter (- input-value-fa-width input-value-a-width) (ack0 "out"))))
								)
							)
							(if (/= 0 (- not-input-value-fa-width not-input-value-a-width))
								(gates
									(gnd (smash (filter (- not-input-value-fa-width not-input-value-a-width) (ack1 "out"))))
									(connect (req "out")
										(smash (filter (- not-input-value-fa-width not-input-value-a-width) (ack0 "out")))
									)
								)
							)
						)
					)
				)
				(("Xor")
					(if (/= 0 input-value-a-width)
						(gates
							(connect (filter input-value-a-width (ack0 "inpA"))
								(filter input-value-a-width (ack1 "out"))
							)
							(connect (filter input-value-a-width (ack1 "inpA"))
								(filter input-value-a-width (ack0 "out"))
							)
						)
					)
					(if (/= 0 not-input-value-a-width)
						(gates
							(connect (filter not-input-value-a-width (ack1 "inpA"))
								(filter not-input-value-a-width (ack1 "out"))
							)
							(connect (filter not-input-value-a-width (ack0 "inpA"))
								(filter not-input-value-a-width (ack0 "out"))
							)
						)
					)
					; extend with value of constant if it is wider than inpA
					(if (> full-add-width a-width)
						(gates
							(if (/= 0 (- input-value-fa-width input-value-a-width))
								(gates
									(connect (req "out")
										(smash (filter (- input-value-fa-width input-value-a-width) (ack1 "out")))
									)
									(gnd (smash (filter (- input-value-fa-width input-value-a-width) (ack0 "out"))))
								)
							)
							(if (/= 0 (- not-input-value-fa-width not-input-value-a-width))
								(gates
									(gnd (smash (filter (- not-input-value-fa-width not-input-value-a-width) (ack1 "out"))))
									(connect (req "out")
										(smash (filter (- not-input-value-fa-width not-input-value-a-width) (ack0 "out")))
									)
								)
							)
						)
					)
				)
			)
			(if (< 0 out-extend-width)
			    ; if output is wider extend it with 0s
				(gates
					(gnd (smash (slice full-add-width out-extend-width (ack1 "out"))))
					(connect (req "out")
						(smash (slice full-add-width out-extend-width (ack0 "out")))
					)
				)
			)
		)
		(arith-op
			(if (/= 0 input-value-adder)
				(cell dual-rail-full-adder-primed
					(filter input-value-adder (node "a0"))
					(filter input-value-adder (node "a1"))
					(filter input-value-adder (node "c0"))
					(filter input-value-adder (node "c1"))
					(filter (* 2 input-value-adder) (node "c0"))
					(filter (* 2 input-value-adder) (node "c1"))
					(filter input-value-adder (ack0 "out"))
					(filter input-value-adder (ack1 "out"))
				)
			)
			(if (/= 0 not-input-value-adder)
				(cell dual-rail-half-adder
					(filter not-input-value-adder (node "a0"))
					(filter not-input-value-adder (node "a1"))
					(filter not-input-value-adder (node "c0"))
					(filter not-input-value-adder (node "c1"))
					(filter (* 2 not-input-value-adder) (node "c0"))
					(filter (* 2 not-input-value-adder) (node "c1"))
					(filter not-input-value-adder (ack0 "out"))
					(filter not-input-value-adder (ack1 "out"))
				)
			)
			(if (< 0 out-extend-width)
				; produce an output carry
				(if (>= input-value-fa-width (expt 2 (- full-add-width 1)))
					(cell dual-rail-full-adder-primed
						(slice (- full-add-width 1) 1 (node "a0"))
						(slice (- full-add-width 1) 1 (node "a1"))
						(slice (- full-add-width 1) 1 (node "c0"))
						(slice (- full-add-width 1) 1 (node "c1"))
						(slice full-add-width 1 (node "c0"))
						(slice full-add-width 1 (node "c1"))
						(slice (- full-add-width 1) 1 (ack0 "out"))
						(slice (- full-add-width 1) 1 (ack1 "out"))
					)
					(cell dual-rail-half-adder
						(slice (- full-add-width 1) 1 (node "a0"))
						(slice (- full-add-width 1) 1 (node "a1"))
						(slice (- full-add-width 1) 1 (node "c0"))
						(slice (- full-add-width 1) 1 (node "c1"))
						(slice full-add-width 1 (node "c0"))
						(slice full-add-width 1 (node "c1"))
						(slice (- full-add-width 1) 1 (ack0 "out"))
						(slice (- full-add-width 1) 1 (ack1 "out"))
					)
				)
				; no need to produce an output carry
				(if (>= input-value-fa-width (expt 2 (- full-add-width 1)))
					(cell dual-rail-xor2 ;; xnor2 (invert output)
						(slice (- full-add-width 1) 1 (node "a0"))
						(slice (- full-add-width 1) 1 (node "a1"))
						(slice (- full-add-width 1) 1 (node "c0"))
						(slice (- full-add-width 1) 1 (node "c1"))
						(slice (- full-add-width 1) 1 (ack1 "out"))
						(slice (- full-add-width 1) 1 (ack0 "out"))
					)
					(cell dual-rail-xor2
						(slice (- full-add-width 1) 1 (node "a0"))
						(slice (- full-add-width 1) 1 (node "a1"))
						(slice (- full-add-width 1) 1 (node "c0"))
						(slice (- full-add-width 1) 1 (node "c1"))
						(slice (- full-add-width 1) 1 (ack0 "out"))
						(slice (- full-add-width 1) 1 (ack1 "out"))
					)
				)
			)
			; set input carry to 0 ("Add") or 1 ("Subtract")
			(if subtractive-op
				(gates
					(connect (req "out") (slice 0 1 (node "c1")))
					(gnd (slice 0 1 (node "c0")))
				)
				(gates
					(gnd (slice 0 1 (node "c1")))
					(connect (req "out") (slice 0 1 (node "c0")))
				)
			)
			; extend output if needed
			(if (< 0 out-extend-width)
				(if signed-op
					; sign-extend output 
					; (use overflow (V) and adder out (msb) [V xor out (msb)] for correct sign)
					(gates
						(cell dual-rail-xor2
							(slice (- full-add-width 1) 1 (node "c0"))
							(slice (- full-add-width 1) 1 (node "c1"))
							(slice full-add-width 1 (node "c0"))
							(slice full-add-width 1 (node "c1"))
							(node "v0")
							(node "v1")
						)
						(cell dual-rail-xor2
							(node "v0")
							(node "v1")
							(slice (- full-add-width 1) 1 (ack0 "out"))
							(slice (- full-add-width 1) 1 (ack1 "out"))
							(node "s0")
							(node "s1")
						)
						(connect (node "s1") (smash (slice full-add-width 
							out-extend-width (ack1 "out")))
						)
						(connect (node "s0") (smash (slice full-add-width 
							out-extend-width (ack0 "out")))
						)
					)
					; unsigned: extend is different for "Add" and "Subtract"
					(if subtractive-op
						; "Subtract": extend with ~carry
						(gates
							(connect (slice full-add-width 1 (node "c1")) 
									 (smash (slice full-add-width out-extend-width (ack0 "out")))
							)
							(connect (slice full-add-width 1 (node "c0")) 
									 (smash (slice full-add-width out-extend-width (ack1 "out")))
							)
						)
						; "Add": extend first bit with carry and more bits with 0s
						(gates
							(connect (slice full-add-width 1 (node "c1")) 
									 (slice full-add-width 1 (ack1 "out"))
							)
							(connect (slice full-add-width 1 (node "c0")) 
									 (slice full-add-width 1 (ack0 "out"))
							)
							(if (< 1 out-extend-width)
								(gates
									(gnd (smash (slice (+ full-add-width 1)
										 (- out-extend-width 1) (ack1 "out")))
									)
									(connect (req "out") (smash (slice (+ full-add-width 1)
											 (- out-extend-width 1) (ack0 "out")))
									)
								)
							)
						)
					)
				)
			)
		)
		(inequality-op
			; bit 0
			(if (and (= full-add-width 1) signed-op) ; invert sign bits
				(if is-input-value-odd
					(gates
						(gnd (slice 0 1 (node "compOut1")))
						(connect (req "out") (slice 0 1 (node "compOut0")))
					)
					(gates
						(connect (slice 0 1 (node "a0")) (slice 0 1 (node "compOut1")))
						(connect (slice 0 1 (node "a1")) (slice 0 1 (node "compOut0")))
					)
				)
				(if is-input-value-odd
					(gates
						(connect (slice 0 1 (node "a0")) (slice 0 1 (node "compOut0")))
						(connect (slice 0 1 (node "a1")) (slice 0 1 (node "compOut1")))
					)
					(gates
						(gnd (slice 0 1 (node "compOut1")))
						(connect (req "out") (slice 0 1 (node "compOut0")))
					)
				)
			)
			; bit 1 to bit full-add-width-2
			(if	(> full-add-width 2)
				(gates
					(if (/= 0 input-value-ineq)
						(gates
							(connect (filter input-value-ineq (node "a0"))
									 (filter input-value-ineq (node "compOut0"))
							)
							(connect (filter input-value-ineq (node "a1"))
									 (filter input-value-ineq (node "compOut1"))
							)
							(connect (filter input-value-ineq (node "a0"))
									 (filter (/ input-value-ineq 2) (node "c1"))
							)
							(connect (filter input-value-ineq (node "a1"))
									 (filter (/ input-value-ineq 2) (node "c0"))
							)
						)
					)
					(if (/= 0 not-input-value-ineq)
						(gates
							(gnd (filter not-input-value-ineq (node "compOut1")))
							(connect (req "out")
									 (smash (filter not-input-value-ineq (node "compOut0")))
							)
							(connect (filter not-input-value-ineq (node "a0"))
									 (filter (/ not-input-value-ineq 2) (node "c0"))
							)
							(connect (filter not-input-value-ineq (node "a1"))
									 (filter (/ not-input-value-ineq 2) (node "c1"))
							)
						)
					)
				)
			)
			; bit full-add-width-1
			(if (> full-add-width 1)
				(if signed-op
					(if (>= input-value-fa-width (expt 2 (- full-add-width 1)))
						(gates
							(gnd (slice (- full-add-width 1) 1 (node "compOut1")))
							(connect (req "out")
									 (slice (- full-add-width 1) 1 (node "compOut0"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a0"))
									 (slice (- full-add-width 2) 1 (node "c1"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a1"))
									 (slice (- full-add-width 2) 1 (node "c0"))
							)
						)
						(gates
							(connect (slice (- full-add-width 1) 1 (node "a0"))
									 (slice (- full-add-width 1) 1 (node "compOut1"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a1"))
									 (slice (- full-add-width 1) 1 (node "compOut0"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a0"))
									 (slice (- full-add-width 2) 1 (node "c0"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a1"))
									 (slice (- full-add-width 2) 1 (node "c1"))
							)
						)
					)
					(if (>= input-value-fa-width (expt 2 (- full-add-width 1)))
						(gates
							(connect (slice (- full-add-width 1) 1 (node "a0"))
									 (slice (- full-add-width 1) 1 (node "compOut0"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a1"))
									 (slice (- full-add-width 1) 1 (node "compOut1"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a0"))
									 (slice (- full-add-width 2) 1 (node "c1"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a1"))
									 (slice (- full-add-width 2) 1 (node "c0"))
							)
						)
						(gates
							(gnd (slice (- full-add-width 1) 1 (node "compOut1")))
							(connect (req "out")
									 (slice (- full-add-width 1) 1 (node "compOut0"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a0"))
									 (slice (- full-add-width 2) 1 (node "c0"))
							)
							(connect (slice (- full-add-width 1) 1 (node "a1"))
									 (slice (- full-add-width 2) 1 (node "c1"))
							)
						)
					)
				)
			)
			(case (param "op")
				(("LessThan" "GreaterThan")
					(macro ineq-comp-tree
						full-add-width
						(node "compOut0")
						(node "compOut1")
						(node "c0")
						(node "c1")
						(ack0 "out")
						(ack1 "out")
					)
				)
				(("GreaterOrEquals" "LessOrEquals")
					(macro ineq-comp-tree  ;; invert out
						full-add-width
						(node "compOut0")
						(node "compOut1")
						(node "c0")
						(node "c1")
						(ack1 "out")
						(ack0 "out")
					)
				)
			)
		)
		(equality-op
			(if (> full-add-width a-width)
				; inpA would be extended: can use a narrow comparator
				(if (not a-signed) 
					; inpA would be extended with 0s
					(if (/= (- input-value-fa-width input-value-a-width) 0)
						; inputs are NOT equal: no need for comparator
						(case (param "op")
							(("Equals")
								(gnd (slice 0 1 (ack1 "out")))
								(connect (req "out")
									(slice 0 1 (ack0 "out"))
								)
							)
							(("NotEquals")
								(connect (req "out")
									(slice 0 1 (ack1 "out"))
								)
								(gnd (slice 0 1 (ack0 "out")))
							)
						)
						; use narrow (a-width) comparator
						(gates
							(if (/= 0 input-value-a-width)
								(gates
									(connect
										(filter input-value-a-width (ack1 "inpA"))
										(filter input-value-a-width (node "compOut0"))
									)
									(connect
										(filter input-value-a-width (ack0 "inpA"))
										(filter input-value-a-width (node "compOut1"))
									)
								)
							)
							(if (/= 0 not-input-value-a-width)
								(gates
									(connect
										(filter not-input-value-a-width (ack1 "inpA"))
										(filter not-input-value-a-width (node "compOut1"))
									)
									(connect
										(filter not-input-value-a-width (ack0 "inpA"))
										(filter not-input-value-a-width (node "compOut0"))
									)
								)
							)
							(case (param "op")
								(("Equals")
									(macro dual-rail-orN   ;; invert out (dual-rail-norN)
										a-width
										(node "compOut0")
										(node "compOut1")
										(ack1 "out")
										(ack0 "out")
									)
								)
								(("NotEquals")
									(macro dual-rail-orN
										a-width
										(node "compOut0")
										(node "compOut1")
										(ack0 "out")
										(ack1 "out")
									)
								)
							)
						)
					)
					; inpA would be sign-extended
					(if (and (/= (- input-value-fa-width input-value-a-width) 0)
							 (/= (- input-value-fa-width input-value-a-width) (- (expt 2 full-add-width) (expt 2 a-width))))
						; inputs are NOT equal: no need for comparator
						(case (param "op")
							(("Equals")
								(gnd (slice 0 1 (ack1 "out")))
								(connect (req "out")
									(slice 0 1 (ack0 "out"))
								)
							)
							(("NotEquals")
								(connect (req "out")
									(slice 0 1 (ack1 "out"))
								)
								(gnd (slice 0 1 (ack0 "out")))
							)
						)
						; use narrow (a-width+1) comparator
						(gates
							(if (/= 0 input-value-a-width)
								(gates
									(connect
										(filter input-value-a-width (ack1 "inpA"))
										(filter input-value-a-width (node "compOut0"))
									)
									(connect
										(filter input-value-a-width (ack0 "inpA"))
										(filter input-value-a-width (node "compOut1"))
									)
								)
							)
							(if (/= 0 not-input-value-a-width)
								(gates
									(connect
										(filter not-input-value-a-width (ack1 "inpA"))
										(filter not-input-value-a-width (node "compOut1"))
									)
									(connect
										(filter not-input-value-a-width (ack0 "inpA"))
										(filter not-input-value-a-width (node "compOut0"))
									)
								)
							)
							; extend comparison by 1 bit (sign-extend inpA)
							(if (= input-value-fa-width (- input-value-fa-width (expt 2 a-width)))
								; bit a-width of constant is 0
								(gates
									(connect (slice (- a-width 1) 1 (ack1 "inpA"))
										(slice a-width 1 (node "compOut1"))
									)
									(connect (slice (- a-width 1) 1 (ack0 "inpA"))
										(slice a-width 1 (node "compOut0"))
									)
								)
								; bit a-width of constant is 1
								(gates
									(connect (slice (- a-width 1) 1 (ack1 "inpA"))
										(slice a-width 1 (node "compOut0"))
									)
									(connect (slice (- a-width 1) 1 (ack0 "inpA"))
										(slice a-width 1 (node "compOut1"))
									)
								)
							)
							(case (param "op")
								(("Equals")
									(macro dual-rail-orN   ;; invert out (dual-rail-norN)
										(+ a-width 1)
										(node "compOut0")
										(node "compOut1")
										(ack1 "out")
										(ack0 "out")
									)
								)
								(("NotEquals")
									(macro dual-rail-orN
										(+ a-width 1)
										(node "compOut0")
										(node "compOut1")
										(ack0 "out")
										(ack1 "out")
									)
								)
							)
						)
					)
				)
				; inpA is not extended: need full-add-width comparator
				(gates
					(if (/= 0 input-value-fa-width)
						(gates
							(connect
								(filter input-value-fa-width (ack1 "inpA"))
								(filter input-value-fa-width (node "compOut0"))
							)
							(connect
								(filter input-value-fa-width (ack0 "inpA"))
								(filter input-value-fa-width (node "compOut1"))
							)
						)
					)
					(if (/= 0 not-input-value-fa-width)
						(gates
							(connect
								(filter not-input-value-fa-width (ack1 "inpA"))
								(filter not-input-value-fa-width (node "compOut1"))
							)
							(connect
								(filter not-input-value-fa-width (ack0 "inpA"))
								(filter not-input-value-fa-width (node "compOut0"))
							)
						)
					)
					(case (param "op")
						(("Equals")
							(macro dual-rail-orN   ;; invert out (dual-rail-norN)
								full-add-width
								(node "compOut0")
								(node "compOut1")
								(ack1 "out")
								(ack0 "out")
							)
						)
						(("NotEquals")
							(macro dual-rail-orN
								full-add-width
								(node "compOut0")
								(node "compOut1")
								(ack0 "out")
								(ack1 "out")
							)
						)
					)
				)
			)
		)
	)
)
