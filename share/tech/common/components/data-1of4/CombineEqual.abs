(defines
	(odd-inputs (= (modulo (param "inputCount") 2) 1))
	(input-odd (= (modulo (param "inputWidth") 2) 1))
	(even-max (* (quotient (param "inputCount") 2) 2))
	(end-start (quotient (* (param "inputWidth") even-max) 2))
	(inp-width-even (quotient (param "inputWidth") 2))
	(inp-width-odd (quotient (+ (param "inputWidth") 1) 2))
	(inp-plural (> (param "inputWidth") 1))
	(plural-inp (> (param "inputCount") 1))
	(create-list (lambda (width)
		(let 
			((curr-start (quotient (* (param "inputWidth") width) 2))
			(cross-start (+ curr-start inp-width-even))
			(rem-start (+ curr-start inp-width-odd)))
			(list
				`(if inp-plural
					(gates
						(connect (slice 0 ,inp-width-even (ack0 (bundle "inp" ,width)))
							(slice ,curr-start ,inp-width-even (ack0 "out"))
						)
						(connect (slice 0 inp-width-even (ack1 (bundle "inp" ,width)))
							(slice ,curr-start inp-width-even (ack1 "out"))
						)
						(connect (slice 0 inp-width-even (ack2 (bundle "inp" ,width)))
							(slice ,curr-start inp-width-even (ack2 "out"))
						)
						(connect (slice 0 inp-width-even (ack3 (bundle "inp" ,width)))
							(slice ,curr-start inp-width-even (ack3 "out"))
						)
						(or (slice 0 inp-width-even (node (bundle "r0lb" ,width))) 
							(slice 0 inp-width-even (ack0 (bundle "inp" ,(+ width 1))))
							(slice 0 inp-width-even (ack2 (bundle "inp" ,(+ width 1))))
						)
						(or (slice 0 inp-width-even (node (bundle "r1lb" ,width)))
							(slice 0 inp-width-even (ack1 (bundle "inp" ,(+ width 1))))
							(slice 0 inp-width-even (ack3 (bundle "inp" ,(+ width 1))))
						)
						(or (slice 0 inp-width-even (node (bundle "r0hb" ,width)))
							(slice 0 inp-width-even (ack0 (bundle "inp" ,(+ width 1))))
							(slice 0 inp-width-even (ack1 (bundle "inp" ,(+ width 1))))
						)
						(or (slice 0 inp-width-even (node (bundle "r1hb" ,width)))
							(slice 0 inp-width-even (ack2 (bundle "inp" ,(+ width 1))))
							(slice 0 inp-width-even (ack3 (bundle "inp" ,(+ width 1))))
						)
						(c-element (slice ,rem-start inp-width-even (ack0 "out"))
							(slice 1 inp-width-even (node (bundle "r0lb" ,width)))
							(slice 0 inp-width-even (node (bundle "r0hb" ,width)))
						)
						(c-element (slice ,rem-start inp-width-even (ack1 "out"))
							(slice 1 inp-width-even (node (bundle "r0lb" ,width)))
							(slice 0 inp-width-even (node (bundle "r1hb" ,width)))
						)
						(c-element (slice ,rem-start inp-width-even (ack2 "out"))
							(slice 1 inp-width-even (node (bundle "r1lb" ,width)))
							(slice 0 inp-width-even (node (bundle "r0hb" ,width)))
						)
						(c-element (slice ,rem-start inp-width-even (ack3 "out"))
							(slice 1 inp-width-even (node (bundle "r1lb" ,width)))
							(slice 0 inp-width-even (node (bundle "r1hb" ,width)))
						)
					)
				)	
				`(connect (slice inp-width-even 1 (ack0 (bundle "inp" ,(+ width 1)))) (slice inp-width-even 1 (node (bundle "r0lb" ,width))))
				`(connect (slice inp-width-even 1 (ack1 (bundle "inp" ,(+ width 1)))) (slice inp-width-even 1 (node (bundle "r1lb" ,width))))
				`(c-element (slice ,cross-start 1 (ack0 "out"))
					(slice 0 1 (node (bundle "r0lb" ,width)))
					(slice ,inp-width-even 1 (ack0 (bundle "inp" ,width))))
				`(c-element (slice ,cross-start 1 (ack1 "out")) 
					(slice 0 1 (node (bundle "r0lb" ,width)) 
					(slice ,inp-width-even 1 (ack1 (bundle "inp" ,width)))))
				`(c-element (slice ,cross-start 1 (ack2 "out")) 
					(slice 0 1 (node (bundle "r1lb" ,width)) 
					(slice ,inp-width-even 1 (ack0 (bundle "inp" ,width)))))
				`(c-element (slice ,cross-start 1 (ack3 "out"))
					(slice 0 1 (node (bundle "r1lb" ,width))
					(slice ,inp-width-even 1 (ack1 (bundle "inp" ,width)))))
			 )
		)
	))
	(comb-eq (lambda ()
		(let
			((ce-tail (lambda (width res)
				(if (= width even-max)
					res
					(ce-tail (+ width 2) (append (create-list width) res))
				)
			)))
			(cons 'gates (ce-tail 0 `()))
		)
	))
)
(nodes
	("r0lb" inp-width-odd 0 even-max)
	("r0hb" inp-width-even 0 even-max) ;; Counter intuitive as odd LS-msb takes first low bit
	("r1lb" inp-width-odd 0 even-max)
	("r1hb" inp-width-even 0 even-max)
)
(gates
	(if input-odd
		(gates
			(if plural-inp
				(macro comb-eq)
			)
			(if odd-inputs
				(gates
					(connect (slice 0 inp-width-odd (ack0 (bundle "inp" even-max))) (slice end-start inp-width-odd (ack0 "out")))
					(connect (slice 0 inp-width-odd (ack1 (bundle "inp" even-max))) (slice end-start inp-width-odd (ack1 "out")))
					(if inp-plural
						(gates
							(connect (slice 0 inp-width-even (ack2 (bundle "inp" even-max))) (slice end-start inp-width-even (ack2 "out")))
							(connect (slice 0 inp-width-even (ack3 (bundle "inp" even-max))) (slice end-start inp-width-even (ack3 "out")))
						)
					)
				)
			)
		)
		(gates
			(connect (combine (ack0 (each "inp"))) (ack0 "out"))
			(connect (combine (ack1 (each "inp"))) (ack1 "out"))
			(connect (combine (ack2 (each "inp"))) (ack2 "out"))
			(connect (combine (ack3 (each "inp"))) (ack3 "out"))
		)
	)
	(connect (req "out") (req (each "inp")))
)
(connections
)
